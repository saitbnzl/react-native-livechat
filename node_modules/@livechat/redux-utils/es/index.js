var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import getOr from 'lodash/fp/getOr';
import omit from 'lodash/fp/omit';
import map from 'lodash/fp/map';
import values from 'lodash/fp/values';
import reduce from 'lodash/fp/reduce';

export var createActionCreator = function createActionCreator(type, actionCreator) {
	var wrappedActionCreator = function wrappedActionCreator() {
		return {
			type: type,
			payload: actionCreator.apply(undefined, arguments)
		};
	};
	wrappedActionCreator.getActionName = function () {
		return type;
	};
	// (wrappedActionCreator: any).toString = (): string => (type);
	return wrappedActionCreator;
};

export var createReducer = function createReducer(intialState, reducersMap) {
	return function reducer(state, action, globalState) {
		var currentState = state || intialState;
		if (reducersMap.hasOwnProperty(action.type)) {
			return reducersMap[action.type](currentState, action.payload, globalState);
		}
		return currentState;
	};
};

export function combineReducers(reducers) {
	var reducerKeys = Object.keys(reducers);
	var finalReducers = {};
	for (var index = 0; index < reducerKeys.length; index++) {
		var key = reducerKeys[index];
		if (typeof reducers[key] === 'function') {
			finalReducers[key] = reducers[key];
		}
	}
	var finalReducerKeys = Object.keys(finalReducers);

	return function combination() {
		var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		var action = arguments[1];
		var globalState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : state;

		var hasChanged = false;
		var nextState = {};
		for (var _index = 0; _index < finalReducerKeys.length; _index++) {
			var _key = finalReducerKeys[_index];
			var reducer = finalReducers[_key];
			var previousStateForKey = state[_key];
			var nextStateForKey = reducer(previousStateForKey, action, globalState);
			nextState[_key] = nextStateForKey;
			hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
		}
		return hasChanged ? nextState : state;
	};
}

export var getOrIdentity = function getOrIdentity(path, state) {
	return getOr(state, path, state);
};

var capitalizeFirstLetter = function capitalizeFirstLetter(text) {
	return text.charAt(0).toUpperCase() + text.slice(1);
};

export var createPropsReducer = function createPropsReducer(propName) {
	var _ref;

	return _ref = {}, _ref['SET_PROPERTY_' + propName.toUpperCase()] = function undefined(state, payload) {
		var _extends2;

		return _extends({}, state, (_extends2 = {}, _extends2[propName] = payload.data, _extends2));
	}, _ref['REMOVE_PROPERTY_' + propName.toUpperCase()] = function undefined(state) {
		return _extends({}, omit(propName, state));
	}, _ref;
};

export var createPropsSelectors = function createPropsSelectors(propName) {
	var _ref2;

	return _ref2 = {}, _ref2['getProperty' + capitalizeFirstLetter(propName)] = function undefined(state) {
		return state[propName];
	}, _ref2;
};

export var createPropsActions = function createPropsActions(propName) {
	var _ref3;

	return _ref3 = {}, _ref3['setProperty' + capitalizeFirstLetter(propName)] = createActionCreator('SET_PROPERTY_' + propName.toUpperCase(), function (data) {
		return {
			data: data
		};
	}), _ref3['removeProperty' + capitalizeFirstLetter(propName)] = createActionCreator('REMOVE_PROPERTY_' + propName.toUpperCase(), function () {
		return {
			propName: propName
		};
	}), _ref3;
};