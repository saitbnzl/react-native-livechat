var _marked = /*#__PURE__*/regeneratorRuntime.mark(sendPing);

import { call, select, spawn, put } from 'redux-saga/effects';
import { delay } from 'redux-saga';

import { waitForState } from '@livechat/saga-utils';
import { propsSelectors, getEnvironment } from '../reducers';
import { sendPostToWebserv } from '../utils/serverRequest';
import propsActions from '../actions/propsActions';
import * as chatStatuses from '../constants/chatStatuses';

var parseResponseToChatStatus = function parseResponseToChatStatus(response) {
	return response.agent_available ? chatStatuses.ONLINE : chatStatuses.OFFLINE;
};

function sendPing() {
	var license, group, visitorId, environment, requestBody, statusPingResponse, chatState, currentChatStatus, connectionStatus, _connectionStatus;

	return regeneratorRuntime.wrap(function sendPing$(_context) {
		while (1) {
			switch (_context.prev = _context.next) {
				case 0:
					if (!true) {
						_context.next = 45;
						break;
					}

					_context.next = 3;
					return select(propsSelectors.getPropertyLicense);

				case 3:
					license = _context.sent;
					_context.next = 6;
					return select(propsSelectors.getPropertyGroup);

				case 6:
					group = _context.sent;
					_context.next = 9;
					return call(waitForState, propsSelectors.getPropertyVisitorId);

				case 9:
					visitorId = _context.sent;
					_context.next = 12;
					return select(getEnvironment);

				case 12:
					environment = _context.sent;
					requestBody = {
						visitor: {
							id: visitorId
						},
						skill: group,
						random_id: String(Math.random())
					};
					_context.prev = 14;
					_context.next = 17;
					return call(sendPostToWebserv, 'status_ping', {
						license: license,
						environment: environment,
						body: requestBody
					}, {
						retry: 10
					});

				case 17:
					statusPingResponse = _context.sent;
					_context.next = 20;
					return select(propsSelectors.getPropertyChatStatus);

				case 20:
					chatState = _context.sent;
					currentChatStatus = parseResponseToChatStatus(statusPingResponse);
					_context.next = 24;
					return select(propsSelectors.getPropertyConnectionStatus);

				case 24:
					connectionStatus = _context.sent;

					if (!(connectionStatus !== 'connected')) {
						_context.next = 28;
						break;
					}

					_context.next = 28;
					return put(propsActions.setPropertyConnectionStatus('connected'));

				case 28:
					if (!(chatState !== currentChatStatus)) {
						_context.next = 31;
						break;
					}

					_context.next = 31;
					return put(propsActions.setPropertyChatStatus(currentChatStatus));

				case 31:
					_context.next = 41;
					break;

				case 33:
					_context.prev = 33;
					_context.t0 = _context['catch'](14);
					_context.next = 37;
					return select(propsSelectors.getPropertyConnectionStatus);

				case 37:
					_connectionStatus = _context.sent;

					if (!(_connectionStatus !== 'disconnected')) {
						_context.next = 41;
						break;
					}

					_context.next = 41;
					return put(propsActions.setPropertyConnectionStatus('disconnected'));

				case 41:
					_context.next = 43;
					return call(delay, 3000);

				case 43:
					_context.next = 0;
					break;

				case 45:
				case 'end':
					return _context.stop();
			}
		}
	}, _marked, this, [[14, 33]]);
}

export default sendPing;